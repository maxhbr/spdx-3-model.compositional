@startuml
left to right direction

title A compositional variant of the SPDX3 Model\nversion is roughly 0.2

together {


map ProfileIdentifier {
    name => String
}
object Actor {
    ???
}
map CreationInfo {
    specVer => SemVer
    profile => [ProfileIdentifier]
    created => DateTime
    dataLicense => 'CC0'
    createdBy => [Actor]
}
CreationInfo::profile .. ProfileIdentifier
CreationInfo::createdBy .. Actor

object Extensions {
    ???
}
map ElementMetadata {
    SPDXID => SPDXID
    creationInfo *--> CreationInfo
    name => Maybe<String>
    summary => Maybe<String>
    description => Maybe<String>
    comment => Maybe<String>
    verifiedUsing => List<IntegrityMethod>
    externalReferences => List<ExternalReference>
    externalIdentifiers => List<ExternalIdentifier>
    extensions *--> Extensions
}
note right
this is not just metadata
and thus needs a better
name
end note
map ExternalReference {
    externalReferenceType => ExternalReferenceType
    locator => IRI
    contentType => Maybe<MediaType>
    comments => Maybe<String>
}
ElementMetadata::externalReferences .. ExternalReference
Map Hash {
    algorithm => HashAlgorithm
    hashValue => String
}
ElementMetadata::verifiedUsing .. Hash
Map ExternalIdentifier {
    externalIdentifierType => ExternalIdentifierType
    identifier => IRI
    comments => Maybe<String>
}
ElementMetadata::externalIdentifiers .. ExternalIdentifier

map Artifact {
    _metadata *--> ElementMetadata
    originatedBy => [Actor]
}

map Collection {
    _metadata *--> ElementMetadata
    collectionType => Other\nSpdxDocument\nBOM
    namespaces => List<NamespaceMap>
    imports => List<ExternalMap>
    elements => List<ElementRef>
    rootElements => List<SPDXID>
    context => Maybe<String>
}


map Relationship {
    _metadata *--> ElementMetadata
    relationshipType => RelationshipType
    completeness => KNOWN\nINCOMPLETE\nUNKNOWN
    from => ElementRef
    to => List<ElementRef>
}

map Identity {
    _metadata *--> ElementMetadata
    IdentityType => Person\nOrganization\nTool
}

map Annotation {
    _metadata *--> ElementMetadata
    statement => String
    annotationType => AnnotationType
    contentType => Maybe<MediaType>
    subject => ElementRef
}


abstract Element {
  SPDXID: SPDXID
  _metadata: ElementMetadata
  ' {method} toElementRef: Element
}
Element <|-- Identity
Element <|-- Relationship
Element <|-- Collection
Element <|-- Artifact
Element <|-- Annotation


object ElementRef {
    Either<SPDXID,Element>
}
note right
either
 - a reference via SPDXID
or
 - an inlined Element
end note
Collection::elements .[hidden].. ElementRef

}

package software {
    map Package {
        packagePurpose => [SoftwarePurpose]
        downloadLocation => Maybe<URL>
        homePage => Maybe<URL>
    }
    map File {
        filePurpose => [SoftwarePurpose]
        contentType => Maybe<MediaType>
    }
    Map Snippet {
        snippetPurpose => [SnippetPurpose]
        location => SnippetLocation
    }
    diamond artifact_software.dia
    artifact_software.dia --> Package
    artifact_software.dia --> File
    artifact_software.dia --> Snippet
    Artifact : software *--> artifact_software.dia
    Artifact::software --> artifact_software.dia
}

package licensing {
    map LicensInformation {
        licenseConcluded => LicenseExpression
        LicenseInfoInFile => LicenseExpression
        CopyrightText => [String]
    }
    Artifact : licensing *--> licensing.LicensInformation
    Artifact::licensing --> LicensInformation
}





' enum RelationshipType {
' DESCRIBES
' AMENDS
' CONTAINS
' ANCESTOR [do we need both?]
' DESCENDANT [do we need both?]
' VARIANT
' DEPENDS_ON
' BUILD_DEPENDENCY
' DEV_DEPENDENCY
' OPTIONAL_DEPENDENCY
' PROVIDED_DEPENDENCY
' TEST_DEPENDENCY
' RUNTIME_DEPENDENCY
' DEPENDENCY_MANIFEST
' DYNAMIC_LINK
' STATIC_LINK
' PREREQUISITE

' BUILD_TOOL
' DEV_TOOL
' TEST_TOOL

' GENERATES

' DISTRIBUTION_ARTIFACT
' EXAMPLE
' DATA_FILE
' TEST_CASE
' DOCUMENTATION
' METAFILE
' TEST
' OPTIONAL_COMPONENT
' PACKAGES

' PATCH
' COPY
' EXPANDED_FROM_ARCHIVE
' FILE_ADDED
' FILE_DELETED
' FILE_MODIFIED

' SUPPLIED_BY *new*
' OTHER
' }
' enum HashAlgorithm {
' SHA1
' SHA224
' SHA256 [default]
' SHA384
' SHA512
' SHA3-224
' SHA3-256
' SHA3-384
' SHA3-512
' MD2
' MD4
' MD5
' MD6
' SPDX-PVC-SHA1
' SPDX-PVC-SHA256
' BLAKE2b-256
' BLAKE2b-384
' BLAKE2b-512
' BLAKE3
' }

' RelationshipType -[hidden]-> HashAlgorithm

@enduml