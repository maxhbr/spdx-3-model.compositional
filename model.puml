@startuml
left to right direction

together {

map CreationInfo {
    specVer => SemVer
    profile => [ProfileIdentifier]
    created => DateTime
    dataLicense => 'CC0'
    createdBy => [Actor]
}
object Extensions
map ElementMetadata {
    SPDXID => SPDXID
    creationInfo *--> CreationInfo
    name => Maybe<String>
    summary => Maybe<String>
    description => Maybe<String>
    comment => Maybe<String>
    annotations => List<Annotation>
    verifiedUsing => List<IntegrityMethod>
    externalReferences => List<ExternalReference>
    externalIdentifiers => List<ExternalIdentifier>
    extensions *--> Extensions
}
map Annotation {
    statement => Maybe<String>
    annotationType => REVIEW\nOTHER
    contentType => Maybe<MediaType>
}
ElementMetadata::annotations .. Annotation
map ExternalReference {
    externalReferenceType => ExternalReferenceType
    locator => IRI
    contentType => Maybe<MediaType>
    comments => Maybe<String>
}
ElementMetadata::externalReferences .. ExternalReference
Map Hash {
    algorithm => HashAlgorithm
    hashValue => String
}
ElementMetadata::verifiedUsing .. Hash
Map ExternalIdentifier {
    externalIdentifierType => ExternalIdentifierType
    identifier => IRI
    comments => Maybe<String>
}
ElementMetadata::externalIdentifiers .. ExternalIdentifier

map Artifact {
    _metadata *--> ElementMetadata
    originatedBy => [Actor]
    software =>
    licensing =>
}

map Collection {
    _metadata *--> ElementMetadata
    collectionType => Other\nSpdxDocument\nBOM
    namespaces => List<NamespaceMap>
    imports => List<ExternalMap>
    elments => List<Element>
    rootElements => List<SPDXID>
    context => Maybe<String>
}


map Relationship {
    _metadata *--> ElementMetadata
    relationshipType => RelationshipType
    completeness => KNOWN\nINCOMPLETE\nUNKNOWN
    from => Element
    to => List<Element>
}

map Actor {
    _metadata *--> ElementMetadata
}

map Identity {
    _metadata *--> ElementMetadata
    IdentityType => Person\nOrganization\nTool
}


package software {
    map Package {
        packagePurpose => [SoftwarePurpose]
        downloadLocation => Maybe<URL>
        homePage => Maybe<URL>
    }
    map File {
        filePurpose => [SoftwarePurpose]
        contentType => Maybe<MediaType>
    }
    Map Snippet {
        snippetPurpose => [SnippetPurpose]
        location => SnippetLocation
    }
    diamond artifact_software.dia
    artifact_software.dia --> Package
    artifact_software.dia --> File
    artifact_software.dia --> Snippet
    Artifact::software --> artifact_software.dia
}

package licensing {
    map LicensInformation {
        licenseConcluded => LicenseExpression
        LicenseInfoInFile => LicenseExpression
        CopyrightText => [String]
    }
    Artifact::licensing --> LicensInformation
}




map ElementRef {
    SPDXID => SPDXID
}
ElementRef::SPDXID .. ElementMetadata::SPDXID



abstract Element {
  SPDXID: SPDXID
  ' {method} toElementRef: Element
}
Element <|-- ElementRef
Element <|-- Identity
Element <|-- Actor
Element <|-- Relationship
Element <|-- Collection
Element <|-- Artifact

}

' enum RelationshipType {
' DESCRIBES
' AMENDS
' CONTAINS
' ANCESTOR [do we need both?]
' DESCENDANT [do we need both?]
' VARIANT
' DEPENDS_ON
' BUILD_DEPENDENCY
' DEV_DEPENDENCY
' OPTIONAL_DEPENDENCY
' PROVIDED_DEPENDENCY
' TEST_DEPENDENCY
' RUNTIME_DEPENDENCY
' DEPENDENCY_MANIFEST
' DYNAMIC_LINK
' STATIC_LINK
' PREREQUISITE

' BUILD_TOOL
' DEV_TOOL
' TEST_TOOL

' GENERATES

' DISTRIBUTION_ARTIFACT
' EXAMPLE
' DATA_FILE
' TEST_CASE
' DOCUMENTATION
' METAFILE
' TEST
' OPTIONAL_COMPONENT
' PACKAGES

' PATCH
' COPY
' EXPANDED_FROM_ARCHIVE
' FILE_ADDED
' FILE_DELETED
' FILE_MODIFIED

' SUPPLIED_BY *new*
' OTHER
' }
' enum HashAlgorithm {
' SHA1
' SHA224
' SHA256 [default]
' SHA384
' SHA512
' SHA3-224
' SHA3-256
' SHA3-384
' SHA3-512
' MD2
' MD4
' MD5
' MD6
' SPDX-PVC-SHA1
' SPDX-PVC-SHA256
' BLAKE2b-256
' BLAKE2b-384
' BLAKE2b-512
' BLAKE3
' }

' RelationshipType -[hidden]-> HashAlgorithm

@enduml